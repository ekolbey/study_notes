Архитетктура
 * python + numpy  
 Ядро алгоритмов. Файлы организованы слеждующим образом
  * Главный модуль **main** ледит в корневой папке программы. Отвечает за интерфейс коммандной строки, выполняет все функции по загрузке данных, созданию и выполнению кластеризации, и создаёт отчёт.
  * папка алгоритмов, в которой лежат файлы модулей, в которых реализованы процедуры  
  algorithm/module.py
 * HTML + matplotlib(PyPlot)  
 визализация и отчёт о результатах кластерзации хранимых в БД. Отчёто является **HTML** файл с графикой, в котором отображаются результаты кластеризации.
  * Для каждого полученного класса отображаютя приписанные ему точки данных в изометрической проекции 3D. Интересующий класс подсвечен видным но не очень ярким цветом на фоне остальных точек, которые нарисованы блекло-серым цветов (фоновые точки)
  * Рядом с изображением каждого кластера выводится ключевая информация о нём

 * SQL lite -- хранение данных и результатов анализа.  
 Структура БД, таблицы:
  *  dataset -- метаданные наборов данных
 	[ dataset_id* | название | описание | дата-вермя добавления (авто) ]
 	Ключ ( dataset_id )
 **  dataset_detail -- детальные данные dataset'ов:
 	[ dataset_id | point_num | 3D точка ]
 	Ключ ( dataset_id, point_num )
 **  algorithm -- справочник названий алгортмов
 Используется для опредления алгоритма по его краткому названию
 	[ algo_id* | algo_type | краткое название алгоритма латиницей | полное название алгоритма | описание | дата-время добавления ]
 	-- algo_type = тип и предназначение алгоритма:
 		MISSING -- заполнение пропущенных значений
 		CLS_NUM -- определние количества классов
 		SEEDPRT -- выбор начальныого разбиения
 	Ключ ( algo_id )
 **  algorithm_tech_detail -- технические детали реализованные алгоритмы
 Хранение информации о реализованных алгоритмах. НЕОБХОДИМ ЕДИНЫЙ ИНТЕРФЕЙС ВЫЗОВА
 	[ algo_id | module_name | proc_name ]
 	-- module_name = имя Python модуля, в котором лежит алгоритм proc_name
 	-- proc_name = имя вывзываемой Python процедуры в модуле module_name алгоритмов
 	Ключ ( algo_id )
 **  result -- метаданные и технические параметры результата работы
 	[ result_id* | dataset_id | missing_fill_algo_id | class_num_algo_id | seed_algo_id | class_cnt | дата-время начала/завершения расчёта | полная строка вызова ]
 	-- missing_fill_algo_id = алгоритм пополнения данных
	-- class_num_algo_id 	= алгоритм выбора количества классов
	-- seed_algo_id 		= алгоритм выбора начального разбиения
	-- class_cnt 			= количество классов
 	Ключ ( result_id )
 **  result_detail -- детальные данные классов и прочих результатов выполненной кластеризации
 	[ result_id | class_num | описание класса | метрики качества | диспресия | прочее ]
 	Ключ ( result_id, class_num )
 **  result_x_class -- соответствие (1-to-many) класса результата и точки данных
 	[ dataset_id | result_id | class_num | point_num ]
 	Ключ ( dataset_id, result_id, class_num, point_num )


(1) Загрузка данных в СУБД
	-- отедльная небольшая прога, получающая на входе CSV с 3D данными и название dataset'а, кладущая его в SQL Lite
(2) Обработка данных
	-- Основа работы
		на входе название dataset'а из БД, алгоритм, вспомогательный алгоритм и прочие параметры
		на выходе отчёт, лежащий в СУБД в отдельной таблице, автоматически вызывается (3) для результатов
(3) Визуализация
	-- на входе название dataset'а. Если проанализирован, то строится отчёт, иначе Ошибка. Выбирается ВСЕГДА последний результат для данного dataset'а


Отчёт:

